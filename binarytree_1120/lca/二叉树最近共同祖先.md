#### 二叉树最近共同祖先

##### **题目描述**

要求编程找到二叉树中任意两个不同节点的最近共同祖先节点（一个节点也可以是它自己的祖先）。（40‘）

##### **输入描述**

第1行输入二叉树，按完全二叉树层次遍历顺序输入该二叉树中的各节点，各节点以空格分隔，若节点不存在则输入`null`。（节点值为char）

第2行输入两个节点的编号 i 和 j， 以空格分隔。从根节点开始对二叉树中的节点按完全二叉树进行编号（编号从1开始）。

##### **输出描述**

输出编号为 i 和 j 的两个节点的最近共同父节点值。如无法找到（查询节点不存在），输出`bad input`。

##### **输入举例**1

```
a b d null c null f
2 7
```

##### **输出举例1**

```
a
```

##### **输入举例**2

```
a b d null c null f
2 6
```

##### **输出举例2**

```
bad input
```

**主要思想**

用链接实现，给每个结点加了`ldad`和`rdad`的指针，在`Node`里加了一个成员变量`flag`，所有结点flag的初始值都为0，用`find`函数根据序号找到题目指定的两个结点，用`Ancester`函数循环让题目指定的两个结点向上走，每经过一个结点就把它的`flag`加1，当出现第一个`flag`为2的结点就是最近的祖先。

**出现问题**

```cpp
while(1)
    {
        b -> flag ++;
        if(b -> flag == 2){cout << b -> data; break;}
        if(b -> rdad == NULL && b -> ldad != NULL){b = b -> ldad;}
        if(b -> ldad == NULL && b -> rdad != NULL){b = b -> rdad;}
    }
```

最后的两个`if`语句并不是不相容的，当满足倒数第二句时，可能`b`已经被置为其父结点，之后再进行第三个`if`语句的判断，仍可能满足，故应该在最后的`if`前加上`else`。（愚蠢的问题）